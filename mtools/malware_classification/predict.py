# %%
import torch
import torch.nn.functional as F
from PIL import Image
import numpy as np
import tempfile
import gdown

# %%
import os
import sys

# %%
from .scripts.transform import *
from .resnet import *

def predict(data_or_path, mode='bmp'):  # support bmp, pe, bytes, raw types
    use_cuda = torch.cuda.is_available() and 'USE_CUDA' in os.environ
    # %%
    # 加载模型字典
    model_state_dict_path = os.path.join(os.path.dirname(sys.modules["mtools"].__file__), 'trained_models/malware_classification%resnet34%best.pt')  # 要使用的模型字典地址

    if use_cuda:
        model_state_dict = torch.load(model_state_dict_path)
        model = ResNet(num_block=[3, 4, 6, 3]).cuda()

    else:
        model_state_dict = torch.load(
            model_state_dict_path, map_location=torch.device('cpu'))
        model = ResNet(num_block=[3, 4, 6, 3])
    model.load_state_dict(model_state_dict)
    model.eval()
    
    try:
        if mode == "bmp":
            img = Image.open(data_or_path)
            img = img.resize((64, 64))
            img_mat = np.asarray(img, dtype=np.float32)
            img_mat = np.reshape(img_mat, (1, 64, 64))
            img_mat = np.repeat(img_mat, 3, axis=0)
            img_mat = torch.from_numpy(img_mat)
            if use_cuda:
                img_mat = torch.unsqueeze(img_mat, axis=0).cuda()
            else:
                img_mat = torch.unsqueeze(img_mat, axis=0)
            y_pred = model(img_mat)
            return F.softmax(y_pred, 1)[0].tolist()
        if mode == "pe":
            _, bmp_path = tempfile.mkstemp(suffix='.bmp')
            pe2bmp(data_or_path, bmp_path)
            return predict(bmp_path, mode='bmp')
        if mode == "bytes":
            _, bmp_path = tempfile.mkstemp(suffix='.bmp')
            bytes2bmp(data_or_path, bmp_path)
            return predict(bmp_path, mode='bmp')
        else:  # mode == "raw torch tensor 3x64x64"
            y_pred = model(data_or_path)
            return F.softmax(y_pred, 1)[0].tolist()
    except:
        pass
    # 用于表示缺省值，上述代码中，进行格式转换时可能会出现异常，所以缺省值是必要的
    return [1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1]
